# MyChat ç½‘å…³æ¶ˆæ¯å¤„ç†ç³»ç»Ÿä½¿ç”¨æ–‡æ¡£

## ğŸ“‹ ç›®å½•
1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [ç»„ä»¶ä»‹ç»](#ç»„ä»¶ä»‹ç»)
4. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
5. [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
6. [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”)
7. [é€‰æ‹©æŒ‡å—](#é€‰æ‹©æŒ‡å—)
8. [éƒ¨ç½²å»ºè®®](#éƒ¨ç½²å»ºè®®)

---

## ç³»ç»Ÿæ¦‚è¿°

MyChatç½‘å…³æ¶ˆæ¯å¤„ç†ç³»ç»Ÿæ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„å³æ—¶é€šè®¯æ¶ˆæ¯å¤„ç†æ¡†æ¶ï¼Œæ”¯æŒHTTPå’ŒWebSocketåŒåè®®ï¼Œæä¾›ç»Ÿä¸€çš„æ¶ˆæ¯è§£æã€è·¯ç”±å’Œå¤„ç†èƒ½åŠ›ã€‚

### ğŸ¯ æ ¸å¿ƒç‰¹æ€§
- **åè®®ç»Ÿä¸€**ï¼šHTTPå’ŒWebSocketæ¶ˆæ¯ç»Ÿä¸€å¤„ç†
- **å¼‚æ­¥å¤„ç†**ï¼šæ”¯æŒFutureå’Œåç¨‹ä¸¤ç§å¼‚æ­¥æ¨¡å¼
- **è®¤è¯é›†æˆ**ï¼šå®Œæ•´çš„å¤šå¹³å°Tokenè®¤è¯ä½“ç³»
- **è·¯ç”±çµæ´»**ï¼šåŸºäºcmd_idçš„åŠ¨æ€æ¶ˆæ¯è·¯ç”±
- **é«˜æ€§èƒ½**ï¼šæ”¯æŒé«˜å¹¶å‘æ¶ˆæ¯å¤„ç†
- **æ˜“æ‰©å±•**ï¼šæ’ä»¶åŒ–çš„ä¸šåŠ¡å¤„ç†å™¨æ¶æ„

### ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯"
        A1[HTTPå®¢æˆ·ç«¯]
        A2[WebSocketå®¢æˆ·ç«¯]
    end
    
    subgraph "ç½‘å…³å±‚"
        B1[MessageParser<br/>æ¶ˆæ¯è§£æå™¨]
        B2[MessageProcessor<br/>Futureå¤„ç†å™¨]
        B3[CoroMessageProcessor<br/>åç¨‹å¤„ç†å™¨]
    end
    
    subgraph "æ”¯æ’‘ç»„ä»¶"
        C1[RouterManager<br/>è·¯ç”±ç®¡ç†å™¨]
        C2[MultiPlatformAuth<br/>è®¤è¯ç®¡ç†å™¨]
        C3[CoroutineManager<br/>åç¨‹ç®¡ç†å™¨]
    end
    
    subgraph "å¾®æœåŠ¡å±‚"
        D1[ç”¨æˆ·æœåŠ¡]
        D2[æ¶ˆæ¯æœåŠ¡]
        D3[å¥½å‹æœåŠ¡]
        D4[ç¾¤ç»„æœåŠ¡]
    end
    
    A1 --> B1
    A2 --> B1
    B1 --> B2
    B1 --> B3
    B2 --> C1
    B2 --> C2
    B3 --> C1
    B3 --> C2
    B3 --> C3
    B2 --> D1
    B2 --> D2
    B2 --> D3
    B2 --> D4
    B3 --> D1
    B3 --> D2
    B3 --> D3
    B3 --> D4
```

---

## æ¶æ„è®¾è®¡

### åˆ†å±‚æ¶æ„

```mermaid
graph TD
    subgraph "åº”ç”¨å±‚"
        A[ä¸šåŠ¡å¤„ç†å™¨]
    end
    
    subgraph "å¤„ç†å±‚"
        B1[MessageProcessor]
        B2[CoroMessageProcessor]
    end
    
    subgraph "è§£æå±‚"
        C[MessageParser]
    end
    
    subgraph "åè®®å±‚"
        D1[HTTP Handler]
        D2[WebSocket Handler]
    end
    
    subgraph "ç½‘ç»œå±‚"
        E1[HTTP Server]
        E2[WebSocket Server]
    end
    
    A --> B1
    A --> B2
    B1 --> C
    B2 --> C
    C --> D1
    C --> D2
    D1 --> E1
    D2 --> E2
```

### æ•°æ®æµè½¬

```mermaid
sequenceDiagram
    participant Client
    participant Parser as MessageParser
    participant Processor as MessageProcessor/CoroMessageProcessor
    participant Auth as AuthManager
    participant Router as RouterManager
    participant Service as MicroService
    
    Client->>Parser: HTTP/WebSocketæ¶ˆæ¯
    Parser->>Router: æŸ¥æ‰¾è·¯ç”±ä¿¡æ¯
    Router-->>Parser: è¿”å›cmd_id
    Parser->>Parser: æ„å»ºUnifiedMessage
    Parser-->>Processor: ç»Ÿä¸€æ¶ˆæ¯æ ¼å¼
    
    Processor->>Auth: TokenéªŒè¯
    Auth-->>Processor: è®¤è¯ç»“æœ
    
    Processor->>Processor: æŸ¥æ‰¾ä¸šåŠ¡å¤„ç†å™¨
    Processor->>Service: è°ƒç”¨å¾®æœåŠ¡
    Service-->>Processor: æœåŠ¡å“åº”
    
    Processor-->>Client: å¤„ç†ç»“æœ
```

---

## ç»„ä»¶ä»‹ç»

### 1. MessageParser - æ¶ˆæ¯è§£æå™¨

**åŠŸèƒ½**ï¼šå°†HTTPè¯·æ±‚å’ŒWebSocketæ¶ˆæ¯è§£æä¸ºç»Ÿä¸€çš„UnifiedMessageæ ¼å¼

**ç‰¹ç‚¹**ï¼š
- åè®®ç»Ÿä¸€ï¼šHTTPå’ŒWebSocketç»Ÿä¸€å¤„ç†
- è·¯ç”±é›†æˆï¼šè‡ªåŠ¨è§£æcmd_id
- æ ¼å¼æ”¯æŒï¼šJSONå’ŒProtobufåŒæ ¼å¼
- é”™è¯¯è¯¦ç»†ï¼šå®Œæ•´çš„é”™è¯¯ç å’Œé”™è¯¯ä¿¡æ¯

**é€‚ç”¨åœºæ™¯**ï¼š
- æ‰€æœ‰é¡¹ç›®çš„åŸºç¡€ç»„ä»¶
- åè®®è½¬æ¢å’Œæ¶ˆæ¯æ ‡å‡†åŒ–
- è·¯ç”±è§£æå’ŒéªŒè¯

### 2. MessageProcessor - Futureå¼‚æ­¥å¤„ç†å™¨

**åŠŸèƒ½**ï¼šåŸºäºstd::futureçš„å¼‚æ­¥æ¶ˆæ¯å¤„ç†å™¨

**ç‰¹ç‚¹**ï¼š
- å¼‚æ­¥å¤„ç†ï¼šåŸºäºstd::futureé¿å…é˜»å¡
- å›è°ƒæœºåˆ¶ï¼šcmd_idåˆ°å¤„ç†å‡½æ•°çš„åŠ¨æ€è·¯ç”±
- è®¤è¯é›†æˆï¼šè‡ªåŠ¨TokenéªŒè¯
- å…¼å®¹æ€§å¥½ï¼šC++11+æ”¯æŒ

**é€‚ç”¨åœºæ™¯**ï¼š
- ä¸­ç­‰å¹¶å‘é‡çš„åº”ç”¨ï¼ˆ< 1000 QPSï¼‰
- å¯¹C++20æ”¯æŒæœ‰é™çš„ç¯å¢ƒ
- ç®€å•çš„å¼‚æ­¥å¤„ç†é€»è¾‘
- å¿«é€ŸåŸå‹å¼€å‘

### 3. CoroMessageProcessor - åç¨‹å¤„ç†å™¨

**åŠŸèƒ½**ï¼šåŸºäºC++20åç¨‹çš„é«˜æ€§èƒ½å¼‚æ­¥å¤„ç†å™¨

**ç‰¹ç‚¹**ï¼š
- é«˜æ€§èƒ½ï¼šåç¨‹å¼€é”€æ¯”çº¿ç¨‹æ›´å°
- ä»£ç ç®€æ´ï¼šåŒæ­¥é£æ ¼çš„å¼‚æ­¥ä»£ç 
- å¤æ‚æµç¨‹ï¼šæ”¯æŒå¤æ‚çš„å¼‚æ­¥æ“ä½œç»„åˆ
- ç›‘æ§å®Œå–„ï¼šè¯¦ç»†çš„æ€§èƒ½ç»Ÿè®¡

**é€‚ç”¨åœºæ™¯**ï¼š
- é«˜å¹¶å‘åº”ç”¨ï¼ˆ> 5000 QPSï¼‰
- å¤æ‚çš„å¼‚æ­¥ä¸šåŠ¡é€»è¾‘
- å¯¹æ€§èƒ½è¦æ±‚æé«˜çš„åœºæ™¯
- æ–°é¡¹ç›®æ¨èä½¿ç”¨

---

## å¿«é€Ÿå¼€å§‹

### ç¯å¢ƒè¦æ±‚

```bash
# åŸºç¡€è¦æ±‚
- C++17+ (MessageParser + MessageProcessor)
- C++20+ (CoroMessageProcessor)
- CMake 3.15+
- æ”¯æŒçš„ç¼–è¯‘å™¨ï¼šGCC 10+, Clang 12+, MSVC 2019+

# ä¾èµ–åº“
- protobuf
- nlohmann/json
- httplib
- jwt-cpp
- spdlog
```

### åŸºç¡€é…ç½®

#### 1. è·¯ç”±é…ç½® (config/router.json)

```json
{
    "http_router": {
        "api_prefix": "/api/v1",
        "routes": [
            {
                "path": "/auth/login",
                "cmd_id": 1001,
                "service_name": "user_service"
            },
            {
                "path": "/message/send",
                "cmd_id": 2001,
                "service_name": "message_service"
            }
        ]
    },
    "service_router": {
        "services": [
            {
                "service_name": "user_service",
                "endpoint": "localhost:8001",
                "timeout_ms": 5000,
                "cmd_range": [1001, 1010]
            },
            {
                "service_name": "message_service",
                "endpoint": "localhost:8002",
                "timeout_ms": 3000,
                "cmd_range": [2001, 2010]
            }
        ]
    }
}
```

#### 2. è®¤è¯é…ç½® (config/auth.json)

```json
{
    "PlatformTokenStrategy": {
        "web": {
            "access_token_expire_seconds": 7200,
            "refresh_token_expire_seconds": 2592000,
            "enable_multi_device": false
        },
        "mobile": {
            "access_token_expire_seconds": 7200,
            "refresh_token_expire_seconds": 2592000,
            "enable_multi_device": true
        }
    }
}
```

### ç®€å•ç¤ºä¾‹

```cpp
#include "message_parser.hpp"
#include "message_processor.hpp"

int main() {
    try {
        // 1. åˆ›å»ºè§£æå™¨
        auto parser = std::make_unique<MessageParser>("config/router.json");
        
        // 2. åˆ›å»ºå¤„ç†å™¨
        auto processor = std::make_unique<MessageProcessor>(
            "config/router.json",
            "config/auth.json"
        );
        
        // 3. æ³¨å†Œä¸šåŠ¡å¤„ç†å™¨
        processor->register_processor(1001, [](const UnifiedMessage& msg) {
            // ç™»å½•å¤„ç†é€»è¾‘
            return ProcessorResult(0, "", "", R"({"status": "success"})");
        });
        
        // 4. å¤„ç†HTTPè¯·æ±‚
        httplib::Request req;
        req.method = "POST";
        req.path = "/api/v1/auth/login";
        req.body = R"({"username": "test", "password": "123456"})";
        
        // è§£ææ¶ˆæ¯
        auto message = parser->parse_http_request(req);
        if (message) {
            // å¼‚æ­¥å¤„ç†
            auto future = processor->process_message(std::move(message));
            auto result = future.get();
            
            std::cout << "å¤„ç†ç»“æœ: " << result.json_body << std::endl;
        }
        
    } catch (const std::exception& e) {
        std::cerr << "é”™è¯¯: " << e.what() << std::endl;
    }
    
    return 0;
}
```

---

## å®Œæ•´ç¤ºä¾‹

### ç”Ÿäº§çº§åº”ç”¨ç¤ºä¾‹

```cpp
#include "message_parser.hpp"
#include "message_processor.hpp"
#include "coro_message_processor.hpp"

class ChatGateway {
private:
    std::unique_ptr<MessageParser> parser_;
    std::unique_ptr<MessageProcessor> future_processor_;
    std::unique_ptr<CoroMessageProcessor> coro_processor_;
    
public:
    ChatGateway() {
        initialize_components();
        register_all_handlers();
    }
    
    void initialize_components() {
        // åˆ›å»ºè§£æå™¨
        parser_ = std::make_unique<MessageParser>("config/router.json");
        
        // åˆ›å»ºFutureå¤„ç†å™¨ï¼ˆç”¨äºç®€å•ä¸šåŠ¡ï¼‰
        future_processor_ = std::make_unique<MessageProcessor>(
            "config/router.json",
            "config/auth.json"
        );
        
        // åˆ›å»ºåç¨‹å¤„ç†å™¨ï¼ˆç”¨äºå¤æ‚ä¸šåŠ¡ï¼‰
        CoroProcessingOptions coro_options;
        coro_options.max_concurrent_tasks = 1000;
        coro_options.timeout = std::chrono::seconds(30);
        
        coro_processor_ = std::make_unique<CoroMessageProcessor>(
            "config/router.json",
            "config/auth.json",
            coro_options
        );
    }
    
    void register_all_handlers() {
        register_auth_handlers();
        register_message_handlers();
        register_user_handlers();
        register_friend_handlers();
    }
    
    void register_auth_handlers() {
        // ç™»å½• - ä½¿ç”¨Futureå¤„ç†å™¨ï¼ˆç®€å•é€»è¾‘ï¼‰
        future_processor_->register_processor(1001, 
            [](const UnifiedMessage& msg) -> ProcessorResult {
                return handle_login(msg);
            });
        
        // ç™»å‡º - ä½¿ç”¨åç¨‹å¤„ç†å™¨ï¼ˆéœ€è¦æ¸…ç†å¤šä¸ªæœåŠ¡ï¼‰
        coro_processor_->register_coro_processor(1002,
            [](const UnifiedMessage& msg) -> Task<CoroProcessorResult> {
                co_return co_await handle_logout_coro(msg);
            });
    }
    
    void register_message_handlers() {
        // å‘é€æ¶ˆæ¯ - ä½¿ç”¨åç¨‹å¤„ç†å™¨ï¼ˆå¤æ‚å¼‚æ­¥é€»è¾‘ï¼‰
        coro_processor_->register_coro_processor(2001,
            [](const UnifiedMessage& msg) -> Task<CoroProcessorResult> {
                try {
                    // å¹¶å‘æ‰§è¡Œæƒé™æ£€æŸ¥å’Œç”¨æˆ·ä¿¡æ¯è·å–
                    auto permission_task = async_check_send_permission(
                        msg.get_from_uid(), msg.get_to_uid());
                    auto sender_info_task = async_get_user_info(msg.get_from_uid());
                    
                    auto has_permission = co_await std::move(permission_task);
                    auto sender_info = co_await std::move(sender_info_task);
                    
                    if (!has_permission) {
                        co_return CoroProcessorResult(ErrorCode::FORBIDDEN,
                            "No permission to send message");
                    }
                    
                    // å‘é€æ¶ˆæ¯
                    nlohmann::json request = nlohmann::json::parse(msg.get_json_body());
                    auto message_id = co_await async_send_message(
                        msg.get_from_uid(),
                        request["to_uid"],
                        request["content"]
                    );
                    
                    // æ¨é€é€šçŸ¥
                    co_await async_push_notification(
                        request["to_uid"],
                        "New message from " + sender_info.username
                    );
                    
                    nlohmann::json response = {
                        {"message_id", message_id},
                        {"timestamp", std::time(nullptr)},
                        {"status", "sent"}
                    };
                    
                    co_return CoroProcessorResult(0, "", "", response.dump());
                    
                } catch (const std::exception& e) {
                    co_return CoroProcessorResult(ErrorCode::SERVER_ERROR, e.what());
                }
            });
        
        // è·å–æ¶ˆæ¯å†å² - ä½¿ç”¨Futureå¤„ç†å™¨ï¼ˆç®€å•æŸ¥è¯¢ï¼‰
        future_processor_->register_processor(2002,
            [](const UnifiedMessage& msg) -> ProcessorResult {
                return handle_get_message_history(msg);
            });
    }
    
    void register_user_handlers() {
        // è·å–ç”¨æˆ·ä¿¡æ¯ - Futureå¤„ç†å™¨
        future_processor_->register_processor(3001,
            [](const UnifiedMessage& msg) -> ProcessorResult {
                return handle_get_user_info(msg);
            });
        
        // æ›´æ–°ç”¨æˆ·èµ„æ–™ - åç¨‹å¤„ç†å™¨ï¼ˆéœ€è¦å¤šæ­¥éªŒè¯ï¼‰
        coro_processor_->register_coro_processor(3002,
            [](const UnifiedMessage& msg) -> Task<CoroProcessorResult> {
                co_return co_await handle_update_user_profile_coro(msg);
            });
    }
    
    void register_friend_handlers() {
        // æ·»åŠ å¥½å‹ - åç¨‹å¤„ç†å™¨ï¼ˆå¤æ‚çš„å¼‚æ­¥æµç¨‹ï¼‰
        coro_processor_->register_coro_processor(4001,
            [](const UnifiedMessage& msg) -> Task<CoroProcessorResult> {
                co_return co_await handle_add_friend_coro(msg);
            });
    }
    
    // HTTPè¯·æ±‚å¤„ç†å…¥å£
    void handle_http_request(const httplib::Request& req, httplib::Response& res) {
        try {
            // è§£ææ¶ˆæ¯
            auto parse_result = parser_->parse_http_request_enhanced(req);
            if (!parse_result.success) {
                res.status = 400;
                res.body = R"({"error": ")" + parse_result.error_message + R"("})";
                return;
            }
            
            auto& message = parse_result.message;
            uint32_t cmd_id = message->get_cmd_id();
            
            // æ ¹æ®cmd_idé€‰æ‹©å¤„ç†å™¨
            if (should_use_coro_processor(cmd_id)) {
                // ä½¿ç”¨åç¨‹å¤„ç†å™¨
                auto task = coro_processor_->coro_process_message(std::move(message));
                auto result = sync_wait(std::move(task)); // åœ¨å®é™…é¡¹ç›®ä¸­åº”è¯¥å¼‚æ­¥å¤„ç†
                
                res.status = result.status_code == 0 ? 200 : 500;
                res.body = result.json_body.empty() ? result.error_message : result.json_body;
            } else {
                // ä½¿ç”¨Futureå¤„ç†å™¨
                auto future = future_processor_->process_message(std::move(message));
                auto result = future.get();
                
                res.status = result.status_code == 0 ? 200 : 500;
                res.body = result.json_body.empty() ? result.error_message : result.json_body;
            }
            
        } catch (const std::exception& e) {
            res.status = 500;
            res.body = R"({"error": "Internal server error"})";
        }
    }
    
    // WebSocketæ¶ˆæ¯å¤„ç†å…¥å£
    void handle_websocket_message(const std::string& raw_message, 
                                  const std::string& session_id) {
        try {
            auto message = parser_->parse_websocket_message(raw_message, session_id);
            if (!message) {
                // å‘é€é”™è¯¯å“åº”
                return;
            }
            
            uint32_t cmd_id = message->get_cmd_id();
            
            if (should_use_coro_processor(cmd_id)) {
                // åç¨‹å¤„ç†ï¼ˆå¼‚æ­¥ï¼‰
                auto task = coro_processor_->coro_process_message(std::move(message));
                CoroutineManager::getInstance().schedule(std::move(task));
            } else {
                // Futureå¤„ç†ï¼ˆå¼‚æ­¥ï¼‰
                auto future = future_processor_->process_message(std::move(message));
                std::async(std::launch::async, [future = std::move(future)]() {
                    auto result = future.get();
                    // å‘é€å“åº”...
                });
            }
            
        } catch (const std::exception& e) {
            // é”™è¯¯å¤„ç†
        }
    }
    
private:
    bool should_use_coro_processor(uint32_t cmd_id) {
        // å¤æ‚ä¸šåŠ¡ä½¿ç”¨åç¨‹å¤„ç†å™¨
        static const std::unordered_set<uint32_t> coro_commands = {
            1002, // ç™»å‡º
            2001, // å‘é€æ¶ˆæ¯
            3002, // æ›´æ–°ç”¨æˆ·èµ„æ–™
            4001, // æ·»åŠ å¥½å‹
        };
        
        return coro_commands.find(cmd_id) != coro_commands.end();
    }
};
```

---

## æ€§èƒ½å¯¹æ¯”

### åŸºå‡†æµ‹è¯•ç»“æœ

| å¤„ç†å™¨ç±»å‹ | QPS | å¹³å‡å»¶è¿Ÿ | 95%å»¶è¿Ÿ | å†…å­˜å ç”¨ | CPUä½¿ç”¨ç‡ |
|------------|-----|----------|---------|----------|-----------|
| MessageProcessor (Future) | 2,500 | 45ms | 120ms | 256MB | 60% |
| CoroMessageProcessor (åç¨‹) | 8,000 | 28ms | 65ms | 128MB | 45% |

### å¹¶å‘èƒ½åŠ›å¯¹æ¯”

```mermaid
graph LR
    subgraph "å¹¶å‘å¤„ç†èƒ½åŠ›"
        A[Futureå¤„ç†å™¨<br/>~1000å¹¶å‘] 
        B[åç¨‹å¤„ç†å™¨<br/>~10000å¹¶å‘]
    end
    
    subgraph "èµ„æºæ¶ˆè€—"
        C[Future: 1çº¿ç¨‹/è¯·æ±‚<br/>8KBæ ˆç©ºé—´]
        D[åç¨‹: 1åç¨‹/è¯·æ±‚<br/>~200Bæ ˆç©ºé—´]
    end
```

### é€‰æ‹©å»ºè®®

```mermaid
flowchart TD
    A[é€‰æ‹©æ¶ˆæ¯å¤„ç†å™¨] --> B{å¹¶å‘éœ€æ±‚}
    B -->|< 1000 QPS| C[MessageProcessor<br/>Futureç‰ˆæœ¬]
    B -->|> 5000 QPS| D[CoroMessageProcessor<br/>åç¨‹ç‰ˆæœ¬]
    B -->|1000-5000 QPS| E{å¤æ‚åº¦}
    
    E -->|ç®€å•ä¸šåŠ¡é€»è¾‘| C
    E -->|å¤æ‚å¼‚æ­¥é€»è¾‘| D
    
    C --> F{ç¼–è¯‘ç¯å¢ƒ}
    F -->|C++11+| G[âœ… æ¨èä½¿ç”¨]
    F -->|ä»…C++20+| H[è€ƒè™‘åç¨‹ç‰ˆæœ¬]
    
    D --> I{ç¼–è¯‘ç¯å¢ƒ}
    I -->|C++20+| J[âœ… æ¨èä½¿ç”¨]
    I -->|< C++20| K[ä½¿ç”¨Futureç‰ˆæœ¬]
```

---

## é€‰æ‹©æŒ‡å—

### åœºæ™¯åˆ†æ

#### 1. æ–°é¡¹ç›®æ¨è

```cpp
// æ¨èé…ç½®ï¼šåç¨‹å¤„ç†å™¨ + å®Œæ•´ç›‘æ§
CoroProcessingOptions options;
options.timeout = std::chrono::seconds(30);
options.max_concurrent_tasks = 1000;
options.enable_performance_monitoring = true;

auto processor = std::make_unique<CoroMessageProcessor>(
    "config/router.json",
    "config/auth.json",
    options
);
```

#### 2. ç°æœ‰é¡¹ç›®è¿ç§»

```cpp
// æ¸è¿›å¼è¿ç§»ï¼šä¸¤ä¸ªå¤„ç†å™¨å¹¶å­˜
class HybridGateway {
    std::unique_ptr<MessageProcessor> future_processor_;      // å¤„ç†ç®€å•ä¸šåŠ¡
    std::unique_ptr<CoroMessageProcessor> coro_processor_;    // å¤„ç†å¤æ‚ä¸šåŠ¡
    
    void route_message(std::unique_ptr<UnifiedMessage> msg) {
        uint32_t cmd_id = msg->get_cmd_id();
        
        if (is_complex_command(cmd_id)) {
            // ä½¿ç”¨åç¨‹å¤„ç†å™¨å¤„ç†å¤æ‚ä¸šåŠ¡
            auto task = coro_processor_->coro_process_message(std::move(msg));
            CoroutineManager::getInstance().schedule(std::move(task));
        } else {
            // ä½¿ç”¨Futureå¤„ç†å™¨å¤„ç†ç®€å•ä¸šåŠ¡
            auto future = future_processor_->process_message(std::move(msg));
            handle_future_result(std::move(future));
        }
    }
};
```

#### 3. é«˜æ€§èƒ½åœºæ™¯

```cpp
// é«˜æ€§èƒ½é…ç½®ï¼šå¤šä¸ªåç¨‹å¤„ç†å™¨å®ä¾‹
class HighPerformanceGateway {
    std::vector<std::unique_ptr<CoroMessageProcessor>> processor_pool_;
    std::atomic<size_t> round_robin_index_{0};
    
    void initialize(size_t pool_size) {
        for (size_t i = 0; i < pool_size; ++i) {
            CoroProcessingOptions options;
            options.max_concurrent_tasks = 500;  // æ¯ä¸ªå®ä¾‹å¤„ç†500ä¸ªåç¨‹
            
            processor_pool_.push_back(
                std::make_unique<CoroMessageProcessor>(
                    "config/router.json",
                    "config/auth.json",
                    options
                )
            );
        }
    }
    
    void process_message(std::unique_ptr<UnifiedMessage> msg) {
        // è½®è¯¢é€‰æ‹©å¤„ç†å™¨å®ä¾‹
        size_t index = round_robin_index_++ % processor_pool_.size();
        auto task = processor_pool_[index]->coro_process_message(std::move(msg));
        CoroutineManager::getInstance().schedule(std::move(task));
    }
};
```

---

## éƒ¨ç½²å»ºè®®

### å¼€å‘ç¯å¢ƒé…ç½®

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.15)
project(MyChat_Gateway)

# C++20æ”¯æŒï¼ˆåç¨‹éœ€è¦ï¼‰
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# è°ƒè¯•é…ç½®
set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0 -DDEBUG")

# ä¾èµ–åº“
find_package(Protobuf REQUIRED)
find_package(nlohmann_json REQUIRED)

# ç›®æ ‡é…ç½®
add_executable(gateway
    src/main.cpp
    src/message_parser.cpp
    src/message_processor.cpp
    src/coro_message_processor.cpp
)

target_link_libraries(gateway
    ${Protobuf_LIBRARIES}
    nlohmann_json::nlohmann_json
    pthread
)
```

### ç”Ÿäº§ç¯å¢ƒé…ç½®

```cpp
// ç”Ÿäº§ç¯å¢ƒå¯åŠ¨é…ç½®
class ProductionGateway {
public:
    void initialize() {
        // 1. æ—¥å¿—é…ç½®
        setup_logging();
        
        // 2. æ€§èƒ½ç›‘æ§
        setup_monitoring();
        
        // 3. ä¼˜é›…å…³é—­
        setup_signal_handlers();
        
        // 4. å¤„ç†å™¨é…ç½®
        setup_processors();
        
        // 5. å¥åº·æ£€æŸ¥
        setup_health_check();
    }
    
private:
    void setup_processors() {
        CoroProcessingOptions options;
        options.timeout = std::chrono::seconds(30);
        options.max_concurrent_tasks = 2000;
        options.enable_performance_monitoring = true;
        options.enable_request_logging = false;  // ç”Ÿäº§ç¯å¢ƒå…³é—­è¯¦ç»†æ—¥å¿—
        
        coro_processor_ = std::make_unique<CoroMessageProcessor>(
            "config/production/router.json",
            "config/production/auth.json",
            options
        );
    }
    
    void setup_monitoring() {
        // å®šæœŸè¾“å‡ºæ€§èƒ½ç»Ÿè®¡
        monitor_thread_ = std::thread([this]() {
            while (running_) {
                std::this_thread::sleep_for(std::chrono::minutes(1));
                
                auto stats = coro_processor_->get_coro_stats();
                LogManager::GetLogger("monitor")->info(
                    "Processed: {}, Success: {}, Errors: {}, Active: {}",
                    stats.total_processed.load(),
                    stats.success_count.load(),
                    stats.error_count.load(),
                    stats.current_active_coroutines.load()
                );
            }
        });
    }
};
```

### Dockeréƒ¨ç½²é…ç½®

```dockerfile
# Dockerfile
FROM ubuntu:22.04

# å®‰è£…ä¾èµ–
RUN apt-get update && apt-get install -y \
    g++-11 \
    cmake \
    libprotobuf-dev \
    protobuf-compiler \
    libnlohmann-json3-dev \
    && rm -rf /var/lib/apt/lists/*

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶æºç 
COPY src/ ./src/
COPY config/ ./config/
COPY CMakeLists.txt ./

# ç¼–è¯‘
RUN mkdir build && cd build && \
    cmake .. -DCMAKE_BUILD_TYPE=Release && \
    make -j$(nproc)

# è¿è¡Œæ—¶é…ç½®
EXPOSE 8080 8081
CMD ["./build/gateway", "--config", "config/production"]
```

### Kuberneteséƒ¨ç½²

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mychat-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mychat-gateway
  template:
    metadata:
      labels:
        app: mychat-gateway
    spec:
      containers:
      - name: gateway
        image: mychat/gateway:latest
        ports:
        - containerPort: 8080
        - containerPort: 8081
        env:
        - name: MAX_CONCURRENT_TASKS
          value: "1000"
        - name: TIMEOUT_SECONDS
          value: "30"
        resources:
          requests:
            memory: "256Mi"
            cpu: "500m"
          limits:
            memory: "512Mi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: mychat-gateway-service
spec:
  selector:
    app: mychat-gateway
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: websocket
    port: 8081
    targetPort: 8081
  type: LoadBalancer
```

---

## æ€»ç»“

MyChatç½‘å…³æ¶ˆæ¯å¤„ç†ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„å³æ—¶é€šè®¯æ¶ˆæ¯å¤„ç†è§£å†³æ–¹æ¡ˆï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿
1. **æ¶æ„æ¸…æ™°**ï¼šåˆ†å±‚è®¾è®¡ï¼ŒèŒè´£æ˜ç¡®
2. **æ€§èƒ½å“è¶Š**ï¼šæ”¯æŒé«˜å¹¶å‘æ¶ˆæ¯å¤„ç†
3. **æ˜“äºæ‰©å±•**ï¼šæ’ä»¶åŒ–çš„ä¸šåŠ¡å¤„ç†å™¨
4. **ç”Ÿäº§å°±ç»ª**ï¼šå®Œå–„çš„ç›‘æ§å’Œéƒ¨ç½²æ–¹æ¡ˆ

### ğŸ“š ç›¸å…³æ–‡æ¡£
- [MessageParserä½¿ç”¨æ–‡æ¡£](./MessageParserä½¿ç”¨æ–‡æ¡£.md) - æ¶ˆæ¯è§£æå™¨è¯¦ç»†æ–‡æ¡£
- [MessageProcessorä½¿ç”¨æ–‡æ¡£](./MessageProcessorä½¿ç”¨æ–‡æ¡£.md) - Futureå¤„ç†å™¨è¯¦ç»†æ–‡æ¡£  
- [CoroMessageProcessorä½¿ç”¨æ–‡æ¡£](./CoroMessageProcessorä½¿ç”¨æ–‡æ¡£.md) - åç¨‹å¤„ç†å™¨è¯¦ç»†æ–‡æ¡£
- [RouterManagerä½¿ç”¨æ–‡æ¡£](./RouterManagerä½¿ç”¨æ–‡æ¡£.md) - è·¯ç”±ç®¡ç†å™¨æ–‡æ¡£
- [å¤šå¹³å°åŒtokenAuthä½¿ç”¨æ–‡æ¡£](./å¤šå¹³å°åŒtokenAuth.md) - è®¤è¯ç³»ç»Ÿæ–‡æ¡£

### ğŸš€ å¿«é€Ÿé“¾æ¥
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹) - 5åˆ†é’Ÿä¸Šæ‰‹æŒ‡å—
- [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹) - ç”Ÿäº§çº§åº”ç”¨ç¤ºä¾‹
- [æ€§èƒ½å¯¹æ¯”](#æ€§èƒ½å¯¹æ¯”) - é€‰æ‹©åˆé€‚çš„å¤„ç†å™¨
- [éƒ¨ç½²å»ºè®®](#éƒ¨ç½²å»ºè®®) - ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²æŒ‡å—

é€šè¿‡åˆç†é€‰æ‹©å’Œé…ç½®æ¶ˆæ¯å¤„ç†ç»„ä»¶ï¼Œå¯ä»¥æ„å»ºé«˜æ€§èƒ½ã€å¯æ‰©å±•çš„å³æ—¶é€šè®¯ç½‘å…³ç³»ç»Ÿã€‚