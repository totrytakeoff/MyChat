// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: user.proto
// Protobuf C++ Version: 5.29.3

#ifndef user_2eproto_2epb_2eh
#define user_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "base.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_user_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_user_2eproto;
namespace im {
namespace user {
class GetUserInfoRequest;
struct GetUserInfoRequestDefaultTypeInternal;
extern GetUserInfoRequestDefaultTypeInternal _GetUserInfoRequest_default_instance_;
class GetUserInfoResponse;
struct GetUserInfoResponseDefaultTypeInternal;
extern GetUserInfoResponseDefaultTypeInternal _GetUserInfoResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class UpdateUserInfoRequest;
struct UpdateUserInfoRequestDefaultTypeInternal;
extern UpdateUserInfoRequestDefaultTypeInternal _UpdateUserInfoRequest_default_instance_;
class UpdateUserInfoResponse;
struct UpdateUserInfoResponseDefaultTypeInternal;
extern UpdateUserInfoResponseDefaultTypeInternal _UpdateUserInfoResponse_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace user
}  // namespace im
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace im {
namespace user {
enum RegisterType : int {
  REGISTER_UNKNOWN = 0,
  REGISTER_PHONE = 1,
  REGISTER_EMAIL = 2,
  RegisterType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RegisterType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RegisterType_IsValid(int value);
extern const uint32_t RegisterType_internal_data_[];
constexpr RegisterType RegisterType_MIN = static_cast<RegisterType>(0);
constexpr RegisterType RegisterType_MAX = static_cast<RegisterType>(2);
constexpr int RegisterType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
RegisterType_descriptor();
template <typename T>
const std::string& RegisterType_Name(T value) {
  static_assert(std::is_same<T, RegisterType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RegisterType_Name().");
  return RegisterType_Name(static_cast<RegisterType>(value));
}
template <>
inline const std::string& RegisterType_Name(RegisterType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RegisterType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RegisterType_Parse(absl::string_view name, RegisterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RegisterType>(
      RegisterType_descriptor(), name, value);
}
enum Gender : int {
  UNKNOWN = 0,
  MALE = 1,
  FEMALE = 2,
  OTHER = 3,
  Gender_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Gender_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Gender_IsValid(int value);
extern const uint32_t Gender_internal_data_[];
constexpr Gender Gender_MIN = static_cast<Gender>(0);
constexpr Gender Gender_MAX = static_cast<Gender>(3);
constexpr int Gender_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Gender_descriptor();
template <typename T>
const std::string& Gender_Name(T value) {
  static_assert(std::is_same<T, Gender>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Gender_Name().");
  return Gender_Name(static_cast<Gender>(value));
}
template <>
inline const std::string& Gender_Name(Gender value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Gender_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Gender_Parse(absl::string_view name, Gender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Gender>(
      Gender_descriptor(), name, value);
}
enum LoginType : int {
  LOGIN_UNKNOWN = 0,
  LOGIN_ACCOUNT = 1,
  LOGIN_PHONE = 2,
  LOGIN_EMAIL = 3,
  LoginType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  LoginType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool LoginType_IsValid(int value);
extern const uint32_t LoginType_internal_data_[];
constexpr LoginType LoginType_MIN = static_cast<LoginType>(0);
constexpr LoginType LoginType_MAX = static_cast<LoginType>(3);
constexpr int LoginType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
LoginType_descriptor();
template <typename T>
const std::string& LoginType_Name(T value) {
  static_assert(std::is_same<T, LoginType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LoginType_Name().");
  return LoginType_Name(static_cast<LoginType>(value));
}
template <>
inline const std::string& LoginType_Name(LoginType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<LoginType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool LoginType_Parse(absl::string_view name, LoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginType>(
      LoginType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserInfo(const UserInfo& from) : UserInfo(nullptr, from) {}
  inline UserInfo(UserInfo&& from) noexcept
      : UserInfo(nullptr, std::move(from)) {}
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
        &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(UserInfo& a, UserInfo& b) { a.Swap(&b); }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserInfo& from) { UserInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.UserInfo"; }

 protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  UserInfo(::google::protobuf::Arena* arena, const UserInfo& from);
  UserInfo(::google::protobuf::Arena* arena, UserInfo&& from) noexcept
      : UserInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kAccountFieldNumber = 2,
    kNicknameFieldNumber = 3,
    kAvatarFieldNumber = 4,
    kSignatureFieldNumber = 6,
    kPhoneNumberFieldNumber = 10,
    kEmailFieldNumber = 11,
    kAddressFieldNumber = 12,
    kBirthdayFieldNumber = 13,
    kCompanyFieldNumber = 14,
    kJobTitleFieldNumber = 15,
    kWxidFieldNumber = 16,
    kQqidFieldNumber = 17,
    kRealNameFieldNumber = 18,
    kExtraFieldNumber = 19,
    kCreateTimeFieldNumber = 7,
    kGenderFieldNumber = 5,
    kOnlineFieldNumber = 9,
    kLastLoginFieldNumber = 8,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // string account = 2;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // string nickname = 3;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string avatar = 4;
  void clear_avatar() ;
  const std::string& avatar() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_avatar(Arg_&& arg, Args_... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* value);

  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(
      const std::string& value);
  std::string* _internal_mutable_avatar();

  public:
  // string signature = 6;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // string phone_number = 10;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // string email = 11;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string address = 12;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string birthday = 13;
  void clear_birthday() ;
  const std::string& birthday() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_birthday(Arg_&& arg, Args_... args);
  std::string* mutable_birthday();
  PROTOBUF_NODISCARD std::string* release_birthday();
  void set_allocated_birthday(std::string* value);

  private:
  const std::string& _internal_birthday() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_birthday(
      const std::string& value);
  std::string* _internal_mutable_birthday();

  public:
  // string company = 14;
  void clear_company() ;
  const std::string& company() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_company(Arg_&& arg, Args_... args);
  std::string* mutable_company();
  PROTOBUF_NODISCARD std::string* release_company();
  void set_allocated_company(std::string* value);

  private:
  const std::string& _internal_company() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company(
      const std::string& value);
  std::string* _internal_mutable_company();

  public:
  // string job_title = 15;
  void clear_job_title() ;
  const std::string& job_title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_job_title(Arg_&& arg, Args_... args);
  std::string* mutable_job_title();
  PROTOBUF_NODISCARD std::string* release_job_title();
  void set_allocated_job_title(std::string* value);

  private:
  const std::string& _internal_job_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_job_title(
      const std::string& value);
  std::string* _internal_mutable_job_title();

  public:
  // string wxid = 16;
  void clear_wxid() ;
  const std::string& wxid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wxid(Arg_&& arg, Args_... args);
  std::string* mutable_wxid();
  PROTOBUF_NODISCARD std::string* release_wxid();
  void set_allocated_wxid(std::string* value);

  private:
  const std::string& _internal_wxid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wxid(
      const std::string& value);
  std::string* _internal_mutable_wxid();

  public:
  // string qqid = 17;
  void clear_qqid() ;
  const std::string& qqid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qqid(Arg_&& arg, Args_... args);
  std::string* mutable_qqid();
  PROTOBUF_NODISCARD std::string* release_qqid();
  void set_allocated_qqid(std::string* value);

  private:
  const std::string& _internal_qqid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qqid(
      const std::string& value);
  std::string* _internal_mutable_qqid();

  public:
  // string real_name = 18;
  void clear_real_name() ;
  const std::string& real_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_real_name(Arg_&& arg, Args_... args);
  std::string* mutable_real_name();
  PROTOBUF_NODISCARD std::string* release_real_name();
  void set_allocated_real_name(std::string* value);

  private:
  const std::string& _internal_real_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_real_name(
      const std::string& value);
  std::string* _internal_mutable_real_name();

  public:
  // string extra = 19;
  void clear_extra() ;
  const std::string& extra() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extra(Arg_&& arg, Args_... args);
  std::string* mutable_extra();
  PROTOBUF_NODISCARD std::string* release_extra();
  void set_allocated_extra(std::string* value);

  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(
      const std::string& value);
  std::string* _internal_mutable_extra();

  public:
  // int64 create_time = 7;
  void clear_create_time() ;
  ::int64_t create_time() const;
  void set_create_time(::int64_t value);

  private:
  ::int64_t _internal_create_time() const;
  void _internal_set_create_time(::int64_t value);

  public:
  // .im.user.Gender gender = 5;
  void clear_gender() ;
  ::im::user::Gender gender() const;
  void set_gender(::im::user::Gender value);

  private:
  ::im::user::Gender _internal_gender() const;
  void _internal_set_gender(::im::user::Gender value);

  public:
  // bool online = 9;
  void clear_online() ;
  bool online() const;
  void set_online(bool value);

  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);

  public:
  // int64 last_login = 8;
  void clear_last_login() ;
  ::int64_t last_login() const;
  void set_last_login(::int64_t value);

  private:
  ::int64_t _internal_last_login() const;
  void _internal_set_last_login(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:im.user.UserInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 0,
      144, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr avatar_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr birthday_;
    ::google::protobuf::internal::ArenaStringPtr company_;
    ::google::protobuf::internal::ArenaStringPtr job_title_;
    ::google::protobuf::internal::ArenaStringPtr wxid_;
    ::google::protobuf::internal::ArenaStringPtr qqid_;
    ::google::protobuf::internal::ArenaStringPtr real_name_;
    ::google::protobuf::internal::ArenaStringPtr extra_;
    ::int64_t create_time_;
    int gender_;
    bool online_;
    ::int64_t last_login_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.UpdateUserInfoResponse) */ {
 public:
  inline UpdateUserInfoResponse() : UpdateUserInfoResponse(nullptr) {}
  ~UpdateUserInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateUserInfoResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateUserInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUserInfoResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUserInfoResponse(const UpdateUserInfoResponse& from) : UpdateUserInfoResponse(nullptr, from) {}
  inline UpdateUserInfoResponse(UpdateUserInfoResponse&& from) noexcept
      : UpdateUserInfoResponse(nullptr, std::move(from)) {}
  inline UpdateUserInfoResponse& operator=(const UpdateUserInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserInfoResponse& operator=(UpdateUserInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserInfoResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateUserInfoResponse*>(
        &_UpdateUserInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(UpdateUserInfoResponse& a, UpdateUserInfoResponse& b) { a.Swap(&b); }
  inline void Swap(UpdateUserInfoResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUserInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUserInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUserInfoResponse& from) { UpdateUserInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateUserInfoResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.UpdateUserInfoResponse"; }

 protected:
  explicit UpdateUserInfoResponse(::google::protobuf::Arena* arena);
  UpdateUserInfoResponse(::google::protobuf::Arena* arena, const UpdateUserInfoResponse& from);
  UpdateUserInfoResponse(::google::protobuf::Arena* arena, UpdateUserInfoResponse&& from) noexcept
      : UpdateUserInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBaseFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .im.base.BaseResponse base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::im::base::BaseResponse& base() const;
  PROTOBUF_NODISCARD ::im::base::BaseResponse* release_base();
  ::im::base::BaseResponse* mutable_base();
  void set_allocated_base(::im::base::BaseResponse* value);
  void unsafe_arena_set_allocated_base(::im::base::BaseResponse* value);
  ::im::base::BaseResponse* unsafe_arena_release_base();

  private:
  const ::im::base::BaseResponse& _internal_base() const;
  ::im::base::BaseResponse* _internal_mutable_base();

  public:
  // .im.user.UserInfo user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::im::user::UserInfo& user() const;
  PROTOBUF_NODISCARD ::im::user::UserInfo* release_user();
  ::im::user::UserInfo* mutable_user();
  void set_allocated_user(::im::user::UserInfo* value);
  void unsafe_arena_set_allocated_user(::im::user::UserInfo* value);
  ::im::user::UserInfo* unsafe_arena_release_user();

  private:
  const ::im::user::UserInfo& _internal_user() const;
  ::im::user::UserInfo* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:im.user.UpdateUserInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateUserInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::im::base::BaseResponse* base_;
    ::im::user::UserInfo* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UpdateUserInfoRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.UpdateUserInfoRequest) */ {
 public:
  inline UpdateUserInfoRequest() : UpdateUserInfoRequest(nullptr) {}
  ~UpdateUserInfoRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateUserInfoRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateUserInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUserInfoRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUserInfoRequest(const UpdateUserInfoRequest& from) : UpdateUserInfoRequest(nullptr, from) {}
  inline UpdateUserInfoRequest(UpdateUserInfoRequest&& from) noexcept
      : UpdateUserInfoRequest(nullptr, std::move(from)) {}
  inline UpdateUserInfoRequest& operator=(const UpdateUserInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserInfoRequest& operator=(UpdateUserInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserInfoRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateUserInfoRequest*>(
        &_UpdateUserInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(UpdateUserInfoRequest& a, UpdateUserInfoRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateUserInfoRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUserInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUserInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUserInfoRequest& from) { UpdateUserInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateUserInfoRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.UpdateUserInfoRequest"; }

 protected:
  explicit UpdateUserInfoRequest(::google::protobuf::Arena* arena);
  UpdateUserInfoRequest(::google::protobuf::Arena* arena, const UpdateUserInfoRequest& from);
  UpdateUserInfoRequest(::google::protobuf::Arena* arena, UpdateUserInfoRequest&& from) noexcept
      : UpdateUserInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeaderFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .im.base.IMHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::im::base::IMHeader& header() const;
  PROTOBUF_NODISCARD ::im::base::IMHeader* release_header();
  ::im::base::IMHeader* mutable_header();
  void set_allocated_header(::im::base::IMHeader* value);
  void unsafe_arena_set_allocated_header(::im::base::IMHeader* value);
  ::im::base::IMHeader* unsafe_arena_release_header();

  private:
  const ::im::base::IMHeader& _internal_header() const;
  ::im::base::IMHeader* _internal_mutable_header();

  public:
  // .im.user.UserInfo user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::im::user::UserInfo& user() const;
  PROTOBUF_NODISCARD ::im::user::UserInfo* release_user();
  ::im::user::UserInfo* mutable_user();
  void set_allocated_user(::im::user::UserInfo* value);
  void unsafe_arena_set_allocated_user(::im::user::UserInfo* value);
  ::im::user::UserInfo* unsafe_arena_release_user();

  private:
  const ::im::user::UserInfo& _internal_user() const;
  ::im::user::UserInfo* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:im.user.UpdateUserInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateUserInfoRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::im::base::IMHeader* header_;
    ::im::user::UserInfo* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterResponse(const RegisterResponse& from) : RegisterResponse(nullptr, from) {}
  inline RegisterResponse(RegisterResponse&& from) noexcept
      : RegisterResponse(nullptr, std::move(from)) {}
  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
        &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(RegisterResponse& a, RegisterResponse& b) { a.Swap(&b); }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterResponse& from) { RegisterResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.RegisterResponse"; }

 protected:
  explicit RegisterResponse(::google::protobuf::Arena* arena);
  RegisterResponse(::google::protobuf::Arena* arena, const RegisterResponse& from);
  RegisterResponse(::google::protobuf::Arena* arena, RegisterResponse&& from) noexcept
      : RegisterResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBaseFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .im.base.BaseResponse base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::im::base::BaseResponse& base() const;
  PROTOBUF_NODISCARD ::im::base::BaseResponse* release_base();
  ::im::base::BaseResponse* mutable_base();
  void set_allocated_base(::im::base::BaseResponse* value);
  void unsafe_arena_set_allocated_base(::im::base::BaseResponse* value);
  ::im::base::BaseResponse* unsafe_arena_release_base();

  private:
  const ::im::base::BaseResponse& _internal_base() const;
  ::im::base::BaseResponse* _internal_mutable_base();

  public:
  // .im.user.UserInfo user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::im::user::UserInfo& user() const;
  PROTOBUF_NODISCARD ::im::user::UserInfo* release_user();
  ::im::user::UserInfo* mutable_user();
  void set_allocated_user(::im::user::UserInfo* value);
  void unsafe_arena_set_allocated_user(::im::user::UserInfo* value);
  ::im::user::UserInfo* unsafe_arena_release_user();

  private:
  const ::im::user::UserInfo& _internal_user() const;
  ::im::user::UserInfo* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:im.user.RegisterResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::im::base::BaseResponse* base_;
    ::im::user::UserInfo* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterRequest(const RegisterRequest& from) : RegisterRequest(nullptr, from) {}
  inline RegisterRequest(RegisterRequest&& from) noexcept
      : RegisterRequest(nullptr, std::move(from)) {}
  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
        &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegisterRequest& a, RegisterRequest& b) { a.Swap(&b); }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterRequest& from) { RegisterRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.RegisterRequest"; }

 protected:
  explicit RegisterRequest(::google::protobuf::Arena* arena);
  RegisterRequest(::google::protobuf::Arena* arena, const RegisterRequest& from);
  RegisterRequest(::google::protobuf::Arena* arena, RegisterRequest&& from) noexcept
      : RegisterRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPhoneNumberFieldNumber = 3,
    kEmailFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kNicknameFieldNumber = 6,
    kAvatarFieldNumber = 7,
    kVerifyCodeFieldNumber = 8,
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string phone_number = 3;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // string email = 4;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string password = 5;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string nickname = 6;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string avatar = 7;
  void clear_avatar() ;
  const std::string& avatar() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_avatar(Arg_&& arg, Args_... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* value);

  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(
      const std::string& value);
  std::string* _internal_mutable_avatar();

  public:
  // string verify_code = 8;
  void clear_verify_code() ;
  const std::string& verify_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verify_code(Arg_&& arg, Args_... args);
  std::string* mutable_verify_code();
  PROTOBUF_NODISCARD std::string* release_verify_code();
  void set_allocated_verify_code(std::string* value);

  private:
  const std::string& _internal_verify_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verify_code(
      const std::string& value);
  std::string* _internal_mutable_verify_code();

  public:
  // .im.base.IMHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::im::base::IMHeader& header() const;
  PROTOBUF_NODISCARD ::im::base::IMHeader* release_header();
  ::im::base::IMHeader* mutable_header();
  void set_allocated_header(::im::base::IMHeader* value);
  void unsafe_arena_set_allocated_header(::im::base::IMHeader* value);
  ::im::base::IMHeader* unsafe_arena_release_header();

  private:
  const ::im::base::IMHeader& _internal_header() const;
  ::im::base::IMHeader* _internal_mutable_header();

  public:
  // .im.user.RegisterType type = 2;
  void clear_type() ;
  ::im::user::RegisterType type() const;
  void set_type(::im::user::RegisterType value);

  private:
  ::im::user::RegisterType _internal_type() const;
  void _internal_set_type(::im::user::RegisterType value);

  public:
  // @@protoc_insertion_point(class_scope:im.user.RegisterRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      90, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr avatar_;
    ::google::protobuf::internal::ArenaStringPtr verify_code_;
    ::im::base::IMHeader* header_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoginResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoginResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginResponse(const LoginResponse& from) : LoginResponse(nullptr, from) {}
  inline LoginResponse(LoginResponse&& from) noexcept
      : LoginResponse(nullptr, std::move(from)) {}
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
        &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(LoginResponse& a, LoginResponse& b) { a.Swap(&b); }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoginResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginResponse& from) { LoginResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoginResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.LoginResponse"; }

 protected:
  explicit LoginResponse(::google::protobuf::Arena* arena);
  LoginResponse(::google::protobuf::Arena* arena, const LoginResponse& from);
  LoginResponse(::google::protobuf::Arena* arena, LoginResponse&& from) noexcept
      : LoginResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBaseFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .im.base.BaseResponse base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::im::base::BaseResponse& base() const;
  PROTOBUF_NODISCARD ::im::base::BaseResponse* release_base();
  ::im::base::BaseResponse* mutable_base();
  void set_allocated_base(::im::base::BaseResponse* value);
  void unsafe_arena_set_allocated_base(::im::base::BaseResponse* value);
  ::im::base::BaseResponse* unsafe_arena_release_base();

  private:
  const ::im::base::BaseResponse& _internal_base() const;
  ::im::base::BaseResponse* _internal_mutable_base();

  public:
  // .im.user.UserInfo user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::im::user::UserInfo& user() const;
  PROTOBUF_NODISCARD ::im::user::UserInfo* release_user();
  ::im::user::UserInfo* mutable_user();
  void set_allocated_user(::im::user::UserInfo* value);
  void unsafe_arena_set_allocated_user(::im::user::UserInfo* value);
  ::im::user::UserInfo* unsafe_arena_release_user();

  private:
  const ::im::user::UserInfo& _internal_user() const;
  ::im::user::UserInfo* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:im.user.LoginResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::im::base::BaseResponse* base_;
    ::im::user::UserInfo* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LoginRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LoginRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from) : LoginRequest(nullptr, from) {}
  inline LoginRequest(LoginRequest&& from) noexcept
      : LoginRequest(nullptr, std::move(from)) {}
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
        &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LoginRequest& a, LoginRequest& b) { a.Swap(&b); }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoginRequest& from) { LoginRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LoginRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.LoginRequest"; }

 protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  LoginRequest(::google::protobuf::Arena* arena, LoginRequest&& from) noexcept
      : LoginRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 3,
    kPhoneNumberFieldNumber = 4,
    kEmailFieldNumber = 5,
    kPasswordFieldNumber = 6,
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string account = 3;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // string phone_number = 4;
  void clear_phone_number() ;
  const std::string& phone_number() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone_number(Arg_&& arg, Args_... args);
  std::string* mutable_phone_number();
  PROTOBUF_NODISCARD std::string* release_phone_number();
  void set_allocated_phone_number(std::string* value);

  private:
  const std::string& _internal_phone_number() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone_number(
      const std::string& value);
  std::string* _internal_mutable_phone_number();

  public:
  // string email = 5;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string password = 6;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // .im.base.IMHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::im::base::IMHeader& header() const;
  PROTOBUF_NODISCARD ::im::base::IMHeader* release_header();
  ::im::base::IMHeader* mutable_header();
  void set_allocated_header(::im::base::IMHeader* value);
  void unsafe_arena_set_allocated_header(::im::base::IMHeader* value);
  ::im::base::IMHeader* unsafe_arena_release_header();

  private:
  const ::im::base::IMHeader& _internal_header() const;
  ::im::base::IMHeader* _internal_mutable_header();

  public:
  // .im.user.LoginType type = 2;
  void clear_type() ;
  ::im::user::LoginType type() const;
  void set_type(::im::user::LoginType value);

  private:
  ::im::user::LoginType _internal_type() const;
  void _internal_set_type(::im::user::LoginType value);

  public:
  // @@protoc_insertion_point(class_scope:im.user.LoginRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const LoginRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::google::protobuf::internal::ArenaStringPtr phone_number_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::im::base::IMHeader* header_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GetUserInfoResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.GetUserInfoResponse) */ {
 public:
  inline GetUserInfoResponse() : GetUserInfoResponse(nullptr) {}
  ~GetUserInfoResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetUserInfoResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetUserInfoResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserInfoResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetUserInfoResponse(const GetUserInfoResponse& from) : GetUserInfoResponse(nullptr, from) {}
  inline GetUserInfoResponse(GetUserInfoResponse&& from) noexcept
      : GetUserInfoResponse(nullptr, std::move(from)) {}
  inline GetUserInfoResponse& operator=(const GetUserInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserInfoResponse& operator=(GetUserInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserInfoResponse*>(
        &_GetUserInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GetUserInfoResponse& a, GetUserInfoResponse& b) { a.Swap(&b); }
  inline void Swap(GetUserInfoResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetUserInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetUserInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetUserInfoResponse& from) { GetUserInfoResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetUserInfoResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.GetUserInfoResponse"; }

 protected:
  explicit GetUserInfoResponse(::google::protobuf::Arena* arena);
  GetUserInfoResponse(::google::protobuf::Arena* arena, const GetUserInfoResponse& from);
  GetUserInfoResponse(::google::protobuf::Arena* arena, GetUserInfoResponse&& from) noexcept
      : GetUserInfoResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBaseFieldNumber = 1,
    kUserFieldNumber = 2,
  };
  // .im.base.BaseResponse base = 1;
  bool has_base() const;
  void clear_base() ;
  const ::im::base::BaseResponse& base() const;
  PROTOBUF_NODISCARD ::im::base::BaseResponse* release_base();
  ::im::base::BaseResponse* mutable_base();
  void set_allocated_base(::im::base::BaseResponse* value);
  void unsafe_arena_set_allocated_base(::im::base::BaseResponse* value);
  ::im::base::BaseResponse* unsafe_arena_release_base();

  private:
  const ::im::base::BaseResponse& _internal_base() const;
  ::im::base::BaseResponse* _internal_mutable_base();

  public:
  // .im.user.UserInfo user = 2;
  bool has_user() const;
  void clear_user() ;
  const ::im::user::UserInfo& user() const;
  PROTOBUF_NODISCARD ::im::user::UserInfo* release_user();
  ::im::user::UserInfo* mutable_user();
  void set_allocated_user(::im::user::UserInfo* value);
  void unsafe_arena_set_allocated_user(::im::user::UserInfo* value);
  ::im::user::UserInfo* unsafe_arena_release_user();

  private:
  const ::im::user::UserInfo& _internal_user() const;
  ::im::user::UserInfo* _internal_mutable_user();

  public:
  // @@protoc_insertion_point(class_scope:im.user.GetUserInfoResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetUserInfoResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::im::base::BaseResponse* base_;
    ::im::user::UserInfo* user_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GetUserInfoRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:im.user.GetUserInfoRequest) */ {
 public:
  inline GetUserInfoRequest() : GetUserInfoRequest(nullptr) {}
  ~GetUserInfoRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetUserInfoRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetUserInfoRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetUserInfoRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetUserInfoRequest(const GetUserInfoRequest& from) : GetUserInfoRequest(nullptr, from) {}
  inline GetUserInfoRequest(GetUserInfoRequest&& from) noexcept
      : GetUserInfoRequest(nullptr, std::move(from)) {}
  inline GetUserInfoRequest& operator=(const GetUserInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserInfoRequest& operator=(GetUserInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserInfoRequest*>(
        &_GetUserInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GetUserInfoRequest& a, GetUserInfoRequest& b) { a.Swap(&b); }
  inline void Swap(GetUserInfoRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetUserInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetUserInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetUserInfoRequest& from) { GetUserInfoRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetUserInfoRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "im.user.GetUserInfoRequest"; }

 protected:
  explicit GetUserInfoRequest(::google::protobuf::Arena* arena);
  GetUserInfoRequest(::google::protobuf::Arena* arena, const GetUserInfoRequest& from);
  GetUserInfoRequest(::google::protobuf::Arena* arena, GetUserInfoRequest&& from) noexcept
      : GetUserInfoRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // string account = 2;
  void clear_account() ;
  const std::string& account() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account(Arg_&& arg, Args_... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* value);

  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(
      const std::string& value);
  std::string* _internal_mutable_account();

  public:
  // .im.base.IMHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::im::base::IMHeader& header() const;
  PROTOBUF_NODISCARD ::im::base::IMHeader* release_header();
  ::im::base::IMHeader* mutable_header();
  void set_allocated_header(::im::base::IMHeader* value);
  void unsafe_arena_set_allocated_header(::im::base::IMHeader* value);
  ::im::base::IMHeader* unsafe_arena_release_header();

  private:
  const ::im::base::IMHeader& _internal_header() const;
  ::im::base::IMHeader* _internal_mutable_header();

  public:
  // @@protoc_insertion_point(class_scope:im.user.GetUserInfoRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetUserInfoRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr account_;
    ::im::base::IMHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UserInfo

// string uid = 1;
inline void UserInfo::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& UserInfo::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.uid)
}
inline std::string* UserInfo::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.uid)
  return _s;
}
inline const std::string& UserInfo::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void UserInfo::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* UserInfo::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.uid)
  return _impl_.uid_.Release();
}
inline void UserInfo::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.uid)
}

// string account = 2;
inline void UserInfo::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& UserInfo::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.account)
}
inline std::string* UserInfo::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.account)
  return _s;
}
inline const std::string& UserInfo::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void UserInfo::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* UserInfo::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.account)
  return _impl_.account_.Release();
}
inline void UserInfo::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.account)
}

// string nickname = 3;
inline void UserInfo::clear_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& UserInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.nickname)
}
inline std::string* UserInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.nickname)
  return _s;
}
inline const std::string& UserInfo::_internal_nickname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nickname_.Get();
}
inline void UserInfo::_internal_set_nickname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* UserInfo::release_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void UserInfo::set_allocated_nickname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.nickname)
}

// string avatar = 4;
inline void UserInfo::clear_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& UserInfo::avatar() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.avatar)
  return _internal_avatar();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_avatar(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.avatar)
}
inline std::string* UserInfo::mutable_avatar() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.avatar)
  return _s;
}
inline const std::string& UserInfo::_internal_avatar() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avatar_.Get();
}
inline void UserInfo::_internal_set_avatar(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.avatar_.Mutable( GetArena());
}
inline std::string* UserInfo::release_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.avatar)
  return _impl_.avatar_.Release();
}
inline void UserInfo::set_allocated_avatar(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.avatar)
}

// .im.user.Gender gender = 5;
inline void UserInfo::clear_gender() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gender_ = 0;
}
inline ::im::user::Gender UserInfo::gender() const {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.gender)
  return _internal_gender();
}
inline void UserInfo::set_gender(::im::user::Gender value) {
  _internal_set_gender(value);
  // @@protoc_insertion_point(field_set:im.user.UserInfo.gender)
}
inline ::im::user::Gender UserInfo::_internal_gender() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::user::Gender>(_impl_.gender_);
}
inline void UserInfo::_internal_set_gender(::im::user::Gender value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gender_ = value;
}

// string signature = 6;
inline void UserInfo::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& UserInfo::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.signature)
}
inline std::string* UserInfo::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.signature)
  return _s;
}
inline const std::string& UserInfo::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void UserInfo::_internal_set_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* UserInfo::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.signature)
  return _impl_.signature_.Release();
}
inline void UserInfo::set_allocated_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.signature_.IsDefault()) {
    _impl_.signature_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.signature)
}

// int64 create_time = 7;
inline void UserInfo::clear_create_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.create_time_ = ::int64_t{0};
}
inline ::int64_t UserInfo::create_time() const {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.create_time)
  return _internal_create_time();
}
inline void UserInfo::set_create_time(::int64_t value) {
  _internal_set_create_time(value);
  // @@protoc_insertion_point(field_set:im.user.UserInfo.create_time)
}
inline ::int64_t UserInfo::_internal_create_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.create_time_;
}
inline void UserInfo::_internal_set_create_time(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.create_time_ = value;
}

// int64 last_login = 8;
inline void UserInfo::clear_last_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_ = ::int64_t{0};
}
inline ::int64_t UserInfo::last_login() const {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.last_login)
  return _internal_last_login();
}
inline void UserInfo::set_last_login(::int64_t value) {
  _internal_set_last_login(value);
  // @@protoc_insertion_point(field_set:im.user.UserInfo.last_login)
}
inline ::int64_t UserInfo::_internal_last_login() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_login_;
}
inline void UserInfo::_internal_set_last_login(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_login_ = value;
}

// bool online = 9;
inline void UserInfo::clear_online() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_ = false;
}
inline bool UserInfo::online() const {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.online)
  return _internal_online();
}
inline void UserInfo::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:im.user.UserInfo.online)
}
inline bool UserInfo::_internal_online() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.online_;
}
inline void UserInfo::_internal_set_online(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_ = value;
}

// string phone_number = 10;
inline void UserInfo::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
}
inline const std::string& UserInfo::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.phone_number)
}
inline std::string* UserInfo::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.phone_number)
  return _s;
}
inline const std::string& UserInfo::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void UserInfo::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* UserInfo::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.phone_number)
  return _impl_.phone_number_.Release();
}
inline void UserInfo::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_number_.IsDefault()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.phone_number)
}

// string email = 11;
inline void UserInfo::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserInfo::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.email)
}
inline std::string* UserInfo::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.email)
  return _s;
}
inline const std::string& UserInfo::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void UserInfo::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserInfo::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.email)
  return _impl_.email_.Release();
}
inline void UserInfo::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.email)
}

// string address = 12;
inline void UserInfo::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& UserInfo::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.address)
}
inline std::string* UserInfo::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.address)
  return _s;
}
inline const std::string& UserInfo::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void UserInfo::_internal_set_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* UserInfo::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.address)
  return _impl_.address_.Release();
}
inline void UserInfo::set_allocated_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.address)
}

// string birthday = 13;
inline void UserInfo::clear_birthday() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.birthday_.ClearToEmpty();
}
inline const std::string& UserInfo::birthday() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.birthday)
  return _internal_birthday();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_birthday(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.birthday_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.birthday)
}
inline std::string* UserInfo::mutable_birthday() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_birthday();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.birthday)
  return _s;
}
inline const std::string& UserInfo::_internal_birthday() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.birthday_.Get();
}
inline void UserInfo::_internal_set_birthday(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.birthday_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_birthday() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.birthday_.Mutable( GetArena());
}
inline std::string* UserInfo::release_birthday() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.birthday)
  return _impl_.birthday_.Release();
}
inline void UserInfo::set_allocated_birthday(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.birthday_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.birthday_.IsDefault()) {
    _impl_.birthday_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.birthday)
}

// string company = 14;
inline void UserInfo::clear_company() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_.ClearToEmpty();
}
inline const std::string& UserInfo::company() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.company)
  return _internal_company();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_company(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.company)
}
inline std::string* UserInfo::mutable_company() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.company)
  return _s;
}
inline const std::string& UserInfo::_internal_company() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.company_.Get();
}
inline void UserInfo::_internal_set_company(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_company() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.company_.Mutable( GetArena());
}
inline std::string* UserInfo::release_company() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.company)
  return _impl_.company_.Release();
}
inline void UserInfo::set_allocated_company(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.company_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.company_.IsDefault()) {
    _impl_.company_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.company)
}

// string job_title = 15;
inline void UserInfo::clear_job_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_title_.ClearToEmpty();
}
inline const std::string& UserInfo::job_title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.job_title)
  return _internal_job_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_job_title(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.job_title)
}
inline std::string* UserInfo::mutable_job_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_job_title();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.job_title)
  return _s;
}
inline const std::string& UserInfo::_internal_job_title() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.job_title_.Get();
}
inline void UserInfo::_internal_set_job_title(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_title_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_job_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.job_title_.Mutable( GetArena());
}
inline std::string* UserInfo::release_job_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.job_title)
  return _impl_.job_title_.Release();
}
inline void UserInfo::set_allocated_job_title(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.job_title_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.job_title_.IsDefault()) {
    _impl_.job_title_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.job_title)
}

// string wxid = 16;
inline void UserInfo::clear_wxid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wxid_.ClearToEmpty();
}
inline const std::string& UserInfo::wxid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.wxid)
  return _internal_wxid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_wxid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wxid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.wxid)
}
inline std::string* UserInfo::mutable_wxid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wxid();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.wxid)
  return _s;
}
inline const std::string& UserInfo::_internal_wxid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wxid_.Get();
}
inline void UserInfo::_internal_set_wxid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wxid_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_wxid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wxid_.Mutable( GetArena());
}
inline std::string* UserInfo::release_wxid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.wxid)
  return _impl_.wxid_.Release();
}
inline void UserInfo::set_allocated_wxid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wxid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.wxid_.IsDefault()) {
    _impl_.wxid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.wxid)
}

// string qqid = 17;
inline void UserInfo::clear_qqid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qqid_.ClearToEmpty();
}
inline const std::string& UserInfo::qqid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.qqid)
  return _internal_qqid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_qqid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qqid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.qqid)
}
inline std::string* UserInfo::mutable_qqid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_qqid();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.qqid)
  return _s;
}
inline const std::string& UserInfo::_internal_qqid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.qqid_.Get();
}
inline void UserInfo::_internal_set_qqid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qqid_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_qqid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.qqid_.Mutable( GetArena());
}
inline std::string* UserInfo::release_qqid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.qqid)
  return _impl_.qqid_.Release();
}
inline void UserInfo::set_allocated_qqid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qqid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.qqid_.IsDefault()) {
    _impl_.qqid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.qqid)
}

// string real_name = 18;
inline void UserInfo::clear_real_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.real_name_.ClearToEmpty();
}
inline const std::string& UserInfo::real_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.real_name)
  return _internal_real_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_real_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.real_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.real_name)
}
inline std::string* UserInfo::mutable_real_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_real_name();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.real_name)
  return _s;
}
inline const std::string& UserInfo::_internal_real_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.real_name_.Get();
}
inline void UserInfo::_internal_set_real_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.real_name_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_real_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.real_name_.Mutable( GetArena());
}
inline std::string* UserInfo::release_real_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.real_name)
  return _impl_.real_name_.Release();
}
inline void UserInfo::set_allocated_real_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.real_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.real_name_.IsDefault()) {
    _impl_.real_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.real_name)
}

// string extra = 19;
inline void UserInfo::clear_extra() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_.ClearToEmpty();
}
inline const std::string& UserInfo::extra() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UserInfo.extra)
  return _internal_extra();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_extra(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.UserInfo.extra)
}
inline std::string* UserInfo::mutable_extra() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:im.user.UserInfo.extra)
  return _s;
}
inline const std::string& UserInfo::_internal_extra() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extra_.Get();
}
inline void UserInfo::_internal_set_extra(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_extra() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extra_.Mutable( GetArena());
}
inline std::string* UserInfo::release_extra() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UserInfo.extra)
  return _impl_.extra_.Release();
}
inline void UserInfo::set_allocated_extra(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extra_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.extra_.IsDefault()) {
    _impl_.extra_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.UserInfo.extra)
}

// -------------------------------------------------------------------

// RegisterRequest

// .im.base.IMHeader header = 1;
inline bool RegisterRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::im::base::IMHeader& RegisterRequest::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::IMHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::IMHeader&>(::im::base::_IMHeader_default_instance_);
}
inline const ::im::base::IMHeader& RegisterRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.header)
  return _internal_header();
}
inline void RegisterRequest::unsafe_arena_set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.RegisterRequest.header)
}
inline ::im::base::IMHeader* RegisterRequest::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::IMHeader* RegisterRequest::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::im::base::IMHeader* RegisterRequest::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::IMHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(p);
  }
  return _impl_.header_;
}
inline ::im::base::IMHeader* RegisterRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::IMHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.header)
  return _msg;
}
inline void RegisterRequest::set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.header)
}

// .im.user.RegisterType type = 2;
inline void RegisterRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::im::user::RegisterType RegisterRequest::type() const {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.type)
  return _internal_type();
}
inline void RegisterRequest::set_type(::im::user::RegisterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.type)
}
inline ::im::user::RegisterType RegisterRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::user::RegisterType>(_impl_.type_);
}
inline void RegisterRequest::_internal_set_type(::im::user::RegisterType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string phone_number = 3;
inline void RegisterRequest::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
}
inline const std::string& RegisterRequest::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.phone_number)
}
inline std::string* RegisterRequest::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.phone_number)
  return _s;
}
inline const std::string& RegisterRequest::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void RegisterRequest::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.phone_number)
  return _impl_.phone_number_.Release();
}
inline void RegisterRequest::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_number_.IsDefault()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.phone_number)
}

// string email = 4;
inline void RegisterRequest::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.email)
}

// string password = 5;
inline void RegisterRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.password)
}

// string nickname = 6;
inline void RegisterRequest::clear_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& RegisterRequest::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.nickname)
}
inline std::string* RegisterRequest::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.nickname)
  return _s;
}
inline const std::string& RegisterRequest::_internal_nickname() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nickname_.Get();
}
inline void RegisterRequest::_internal_set_nickname(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_nickname() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.nickname)
  return _impl_.nickname_.Release();
}
inline void RegisterRequest::set_allocated_nickname(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nickname_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.nickname)
}

// string avatar = 7;
inline void RegisterRequest::clear_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.ClearToEmpty();
}
inline const std::string& RegisterRequest::avatar() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.avatar)
  return _internal_avatar();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_avatar(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.avatar)
}
inline std::string* RegisterRequest::mutable_avatar() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.avatar)
  return _s;
}
inline const std::string& RegisterRequest::_internal_avatar() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avatar_.Get();
}
inline void RegisterRequest::_internal_set_avatar(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.avatar_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_avatar() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.avatar)
  return _impl_.avatar_.Release();
}
inline void RegisterRequest::set_allocated_avatar(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avatar_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.avatar)
}

// string verify_code = 8;
inline void RegisterRequest::clear_verify_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verify_code_.ClearToEmpty();
}
inline const std::string& RegisterRequest::verify_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterRequest.verify_code)
  return _internal_verify_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_verify_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verify_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.RegisterRequest.verify_code)
}
inline std::string* RegisterRequest::mutable_verify_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_verify_code();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterRequest.verify_code)
  return _s;
}
inline const std::string& RegisterRequest::_internal_verify_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.verify_code_.Get();
}
inline void RegisterRequest::_internal_set_verify_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verify_code_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_verify_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.verify_code_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_verify_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterRequest.verify_code)
  return _impl_.verify_code_.Release();
}
inline void RegisterRequest::set_allocated_verify_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.verify_code_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.verify_code_.IsDefault()) {
    _impl_.verify_code_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterRequest.verify_code)
}

// -------------------------------------------------------------------

// RegisterResponse

// .im.base.BaseResponse base = 1;
inline bool RegisterResponse::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::im::base::BaseResponse& RegisterResponse::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::BaseResponse* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::BaseResponse&>(::im::base::_BaseResponse_default_instance_);
}
inline const ::im::base::BaseResponse& RegisterResponse::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterResponse.base)
  return _internal_base();
}
inline void RegisterResponse::unsafe_arena_set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.RegisterResponse.base)
}
inline ::im::base::BaseResponse* RegisterResponse::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::BaseResponse* RegisterResponse::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterResponse.base)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::im::base::BaseResponse* RegisterResponse::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::BaseResponse>(GetArena());
    _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(p);
  }
  return _impl_.base_;
}
inline ::im::base::BaseResponse* RegisterResponse::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::BaseResponse* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterResponse.base)
  return _msg;
}
inline void RegisterResponse::set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterResponse.base)
}

// .im.user.UserInfo user = 2;
inline bool RegisterResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void RegisterResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::im::user::UserInfo& RegisterResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::user::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::user::UserInfo&>(::im::user::_UserInfo_default_instance_);
}
inline const ::im::user::UserInfo& RegisterResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.RegisterResponse.user)
  return _internal_user();
}
inline void RegisterResponse::unsafe_arena_set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.RegisterResponse.user)
}
inline ::im::user::UserInfo* RegisterResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::user::UserInfo* RegisterResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.RegisterResponse.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::im::user::UserInfo* RegisterResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::user::UserInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(p);
  }
  return _impl_.user_;
}
inline ::im::user::UserInfo* RegisterResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::im::user::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:im.user.RegisterResponse.user)
  return _msg;
}
inline void RegisterResponse::set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.RegisterResponse.user)
}

// -------------------------------------------------------------------

// LoginRequest

// .im.base.IMHeader header = 1;
inline bool LoginRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::im::base::IMHeader& LoginRequest::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::IMHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::IMHeader&>(::im::base::_IMHeader_default_instance_);
}
inline const ::im::base::IMHeader& LoginRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.header)
  return _internal_header();
}
inline void LoginRequest::unsafe_arena_set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.LoginRequest.header)
}
inline ::im::base::IMHeader* LoginRequest::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::IMHeader* LoginRequest::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginRequest.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::im::base::IMHeader* LoginRequest::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::IMHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(p);
  }
  return _impl_.header_;
}
inline ::im::base::IMHeader* LoginRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::IMHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:im.user.LoginRequest.header)
  return _msg;
}
inline void LoginRequest::set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginRequest.header)
}

// .im.user.LoginType type = 2;
inline void LoginRequest::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::im::user::LoginType LoginRequest::type() const {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.type)
  return _internal_type();
}
inline void LoginRequest::set_type(::im::user::LoginType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:im.user.LoginRequest.type)
}
inline ::im::user::LoginType LoginRequest::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::im::user::LoginType>(_impl_.type_);
}
inline void LoginRequest::_internal_set_type(::im::user::LoginType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string account = 3;
inline void LoginRequest::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& LoginRequest::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.LoginRequest.account)
}
inline std::string* LoginRequest::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:im.user.LoginRequest.account)
  return _s;
}
inline const std::string& LoginRequest::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void LoginRequest::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginRequest.account)
  return _impl_.account_.Release();
}
inline void LoginRequest::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginRequest.account)
}

// string phone_number = 4;
inline void LoginRequest::clear_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.ClearToEmpty();
}
inline const std::string& LoginRequest::phone_number() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.phone_number)
  return _internal_phone_number();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_phone_number(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.LoginRequest.phone_number)
}
inline std::string* LoginRequest::mutable_phone_number() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone_number();
  // @@protoc_insertion_point(field_mutable:im.user.LoginRequest.phone_number)
  return _s;
}
inline const std::string& LoginRequest::_internal_phone_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_number_.Get();
}
inline void LoginRequest::_internal_set_phone_number(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.phone_number_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_phone_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginRequest.phone_number)
  return _impl_.phone_number_.Release();
}
inline void LoginRequest::set_allocated_phone_number(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_number_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_number_.IsDefault()) {
    _impl_.phone_number_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginRequest.phone_number)
}

// string email = 5;
inline void LoginRequest::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& LoginRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.LoginRequest.email)
}
inline std::string* LoginRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:im.user.LoginRequest.email)
  return _s;
}
inline const std::string& LoginRequest::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void LoginRequest::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginRequest.email)
  return _impl_.email_.Release();
}
inline void LoginRequest::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginRequest.email)
}

// string password = 6;
inline void LoginRequest::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:im.user.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// .im.base.BaseResponse base = 1;
inline bool LoginResponse::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::im::base::BaseResponse& LoginResponse::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::BaseResponse* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::BaseResponse&>(::im::base::_BaseResponse_default_instance_);
}
inline const ::im::base::BaseResponse& LoginResponse::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginResponse.base)
  return _internal_base();
}
inline void LoginResponse::unsafe_arena_set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.LoginResponse.base)
}
inline ::im::base::BaseResponse* LoginResponse::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::BaseResponse* LoginResponse::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginResponse.base)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::im::base::BaseResponse* LoginResponse::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::BaseResponse>(GetArena());
    _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(p);
  }
  return _impl_.base_;
}
inline ::im::base::BaseResponse* LoginResponse::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::BaseResponse* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:im.user.LoginResponse.base)
  return _msg;
}
inline void LoginResponse::set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginResponse.base)
}

// .im.user.UserInfo user = 2;
inline bool LoginResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void LoginResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::im::user::UserInfo& LoginResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::user::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::user::UserInfo&>(::im::user::_UserInfo_default_instance_);
}
inline const ::im::user::UserInfo& LoginResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.LoginResponse.user)
  return _internal_user();
}
inline void LoginResponse::unsafe_arena_set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.LoginResponse.user)
}
inline ::im::user::UserInfo* LoginResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::user::UserInfo* LoginResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.LoginResponse.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::im::user::UserInfo* LoginResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::user::UserInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(p);
  }
  return _impl_.user_;
}
inline ::im::user::UserInfo* LoginResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::im::user::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:im.user.LoginResponse.user)
  return _msg;
}
inline void LoginResponse::set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.LoginResponse.user)
}

// -------------------------------------------------------------------

// GetUserInfoRequest

// .im.base.IMHeader header = 1;
inline bool GetUserInfoRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::im::base::IMHeader& GetUserInfoRequest::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::IMHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::IMHeader&>(::im::base::_IMHeader_default_instance_);
}
inline const ::im::base::IMHeader& GetUserInfoRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.GetUserInfoRequest.header)
  return _internal_header();
}
inline void GetUserInfoRequest::unsafe_arena_set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.GetUserInfoRequest.header)
}
inline ::im::base::IMHeader* GetUserInfoRequest::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::IMHeader* GetUserInfoRequest::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.GetUserInfoRequest.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::im::base::IMHeader* GetUserInfoRequest::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::IMHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(p);
  }
  return _impl_.header_;
}
inline ::im::base::IMHeader* GetUserInfoRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::IMHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:im.user.GetUserInfoRequest.header)
  return _msg;
}
inline void GetUserInfoRequest::set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.GetUserInfoRequest.header)
}

// string account = 2;
inline void GetUserInfoRequest::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.ClearToEmpty();
}
inline const std::string& GetUserInfoRequest::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.GetUserInfoRequest.account)
  return _internal_account();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetUserInfoRequest::set_account(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:im.user.GetUserInfoRequest.account)
}
inline std::string* GetUserInfoRequest::mutable_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:im.user.GetUserInfoRequest.account)
  return _s;
}
inline const std::string& GetUserInfoRequest::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_.Get();
}
inline void GetUserInfoRequest::_internal_set_account(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.Set(value, GetArena());
}
inline std::string* GetUserInfoRequest::_internal_mutable_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_.Mutable( GetArena());
}
inline std::string* GetUserInfoRequest::release_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.GetUserInfoRequest.account)
  return _impl_.account_.Release();
}
inline void GetUserInfoRequest::set_allocated_account(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_.IsDefault()) {
    _impl_.account_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:im.user.GetUserInfoRequest.account)
}

// -------------------------------------------------------------------

// GetUserInfoResponse

// .im.base.BaseResponse base = 1;
inline bool GetUserInfoResponse::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::im::base::BaseResponse& GetUserInfoResponse::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::BaseResponse* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::BaseResponse&>(::im::base::_BaseResponse_default_instance_);
}
inline const ::im::base::BaseResponse& GetUserInfoResponse::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.GetUserInfoResponse.base)
  return _internal_base();
}
inline void GetUserInfoResponse::unsafe_arena_set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.GetUserInfoResponse.base)
}
inline ::im::base::BaseResponse* GetUserInfoResponse::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::BaseResponse* GetUserInfoResponse::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.GetUserInfoResponse.base)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::im::base::BaseResponse* GetUserInfoResponse::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::BaseResponse>(GetArena());
    _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(p);
  }
  return _impl_.base_;
}
inline ::im::base::BaseResponse* GetUserInfoResponse::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::BaseResponse* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:im.user.GetUserInfoResponse.base)
  return _msg;
}
inline void GetUserInfoResponse::set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.GetUserInfoResponse.base)
}

// .im.user.UserInfo user = 2;
inline bool GetUserInfoResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void GetUserInfoResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::im::user::UserInfo& GetUserInfoResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::user::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::user::UserInfo&>(::im::user::_UserInfo_default_instance_);
}
inline const ::im::user::UserInfo& GetUserInfoResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.GetUserInfoResponse.user)
  return _internal_user();
}
inline void GetUserInfoResponse::unsafe_arena_set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.GetUserInfoResponse.user)
}
inline ::im::user::UserInfo* GetUserInfoResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::user::UserInfo* GetUserInfoResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.GetUserInfoResponse.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::im::user::UserInfo* GetUserInfoResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::user::UserInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(p);
  }
  return _impl_.user_;
}
inline ::im::user::UserInfo* GetUserInfoResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::im::user::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:im.user.GetUserInfoResponse.user)
  return _msg;
}
inline void GetUserInfoResponse::set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.GetUserInfoResponse.user)
}

// -------------------------------------------------------------------

// UpdateUserInfoRequest

// .im.base.IMHeader header = 1;
inline bool UpdateUserInfoRequest::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline const ::im::base::IMHeader& UpdateUserInfoRequest::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::IMHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::IMHeader&>(::im::base::_IMHeader_default_instance_);
}
inline const ::im::base::IMHeader& UpdateUserInfoRequest::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UpdateUserInfoRequest.header)
  return _internal_header();
}
inline void UpdateUserInfoRequest::unsafe_arena_set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.UpdateUserInfoRequest.header)
}
inline ::im::base::IMHeader* UpdateUserInfoRequest::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::IMHeader* UpdateUserInfoRequest::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UpdateUserInfoRequest.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::IMHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::im::base::IMHeader* UpdateUserInfoRequest::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::IMHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(p);
  }
  return _impl_.header_;
}
inline ::im::base::IMHeader* UpdateUserInfoRequest::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::IMHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:im.user.UpdateUserInfoRequest.header)
  return _msg;
}
inline void UpdateUserInfoRequest::set_allocated_header(::im::base::IMHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::im::base::IMHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.UpdateUserInfoRequest.header)
}

// .im.user.UserInfo user = 2;
inline bool UpdateUserInfoRequest::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UpdateUserInfoRequest::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::im::user::UserInfo& UpdateUserInfoRequest::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::user::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::user::UserInfo&>(::im::user::_UserInfo_default_instance_);
}
inline const ::im::user::UserInfo& UpdateUserInfoRequest::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UpdateUserInfoRequest.user)
  return _internal_user();
}
inline void UpdateUserInfoRequest::unsafe_arena_set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.UpdateUserInfoRequest.user)
}
inline ::im::user::UserInfo* UpdateUserInfoRequest::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::user::UserInfo* UpdateUserInfoRequest::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UpdateUserInfoRequest.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::im::user::UserInfo* UpdateUserInfoRequest::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::user::UserInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(p);
  }
  return _impl_.user_;
}
inline ::im::user::UserInfo* UpdateUserInfoRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::im::user::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:im.user.UpdateUserInfoRequest.user)
  return _msg;
}
inline void UpdateUserInfoRequest::set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.UpdateUserInfoRequest.user)
}

// -------------------------------------------------------------------

// UpdateUserInfoResponse

// .im.base.BaseResponse base = 1;
inline bool UpdateUserInfoResponse::has_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_ != nullptr);
  return value;
}
inline const ::im::base::BaseResponse& UpdateUserInfoResponse::_internal_base() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::base::BaseResponse* p = _impl_.base_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::base::BaseResponse&>(::im::base::_BaseResponse_default_instance_);
}
inline const ::im::base::BaseResponse& UpdateUserInfoResponse::base() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UpdateUserInfoResponse.base)
  return _internal_base();
}
inline void UpdateUserInfoResponse::unsafe_arena_set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }
  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.UpdateUserInfoResponse.base)
}
inline ::im::base::BaseResponse* UpdateUserInfoResponse::release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* released = _impl_.base_;
  _impl_.base_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::base::BaseResponse* UpdateUserInfoResponse::unsafe_arena_release_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UpdateUserInfoResponse.base)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::im::base::BaseResponse* temp = _impl_.base_;
  _impl_.base_ = nullptr;
  return temp;
}
inline ::im::base::BaseResponse* UpdateUserInfoResponse::_internal_mutable_base() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.base_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::base::BaseResponse>(GetArena());
    _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(p);
  }
  return _impl_.base_;
}
inline ::im::base::BaseResponse* UpdateUserInfoResponse::mutable_base() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::im::base::BaseResponse* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:im.user.UpdateUserInfoResponse.base)
  return _msg;
}
inline void UpdateUserInfoResponse::set_allocated_base(::im::base::BaseResponse* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.base_ = reinterpret_cast<::im::base::BaseResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.UpdateUserInfoResponse.base)
}

// .im.user.UserInfo user = 2;
inline bool UpdateUserInfoResponse::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void UpdateUserInfoResponse::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::im::user::UserInfo& UpdateUserInfoResponse::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::im::user::UserInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::im::user::UserInfo&>(::im::user::_UserInfo_default_instance_);
}
inline const ::im::user::UserInfo& UpdateUserInfoResponse::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:im.user.UpdateUserInfoResponse.user)
  return _internal_user();
}
inline void UpdateUserInfoResponse::unsafe_arena_set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:im.user.UpdateUserInfoResponse.user)
}
inline ::im::user::UserInfo* UpdateUserInfoResponse::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::im::user::UserInfo* UpdateUserInfoResponse::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:im.user.UpdateUserInfoResponse.user)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::im::user::UserInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::im::user::UserInfo* UpdateUserInfoResponse::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::im::user::UserInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(p);
  }
  return _impl_.user_;
}
inline ::im::user::UserInfo* UpdateUserInfoResponse::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::im::user::UserInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:im.user.UpdateUserInfoResponse.user)
  return _msg;
}
inline void UpdateUserInfoResponse::set_allocated_user(::im::user::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.user_ = reinterpret_cast<::im::user::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:im.user.UpdateUserInfoResponse.user)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace user
}  // namespace im


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::im::user::RegisterType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::im::user::RegisterType>() {
  return ::im::user::RegisterType_descriptor();
}
template <>
struct is_proto_enum<::im::user::Gender> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::im::user::Gender>() {
  return ::im::user::Gender_descriptor();
}
template <>
struct is_proto_enum<::im::user::LoginType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::im::user::LoginType>() {
  return ::im::user::LoginType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // user_2eproto_2epb_2eh
